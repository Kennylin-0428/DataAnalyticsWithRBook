# 控制流程 {#controlstructure}


## 條件判斷
### if-else敘述
**if-else**敘述使用在邏輯判斷，若需要依條件改變需要執行的程式碼，就會使用**if-else**，若**if**後所接邏輯判斷為**真(TRUE)**，就會執行if下方之程式碼，若為**偽(FALSE)**，則執行**else**下方之程式碼，若程式中沒有**else**片段，則不執行任何程式碼。
```{r echo=FALSE}
knitr::include_graphics("figure/ifelse.png")
```

`if`與`else`下方的程式碼必須要使用`{}`將程式碼包起來，若程式碼只有一行，可省略`{}`，但為閱讀方便，建議不要省略`{}`。

舉例來說，若考試分數**大於等於60分**，則印出**及格**字樣，小於60分則印出**不及格**字樣，程式範例如下:

```{r}
score<-59
if(score>=60){
  print("及格")
}else{
  print("不及格")
}
```

```{r}
score<-80
if(score>=60){
  print("及格")
}else{
  print("不及格")
}
```

### if-else if-else
很多時候必須要使用多重邏輯判斷，若考試分數大於等於90分，印出**優良**，介於60到90分間，印出**及格**，小於60分則印出**不及格**，此時就會用到多重邏輯，使用多重邏輯時，會在`if`和`else`間新增邏輯區段**else if**，程式範例如下:

```{r}
score<-95
if(score>=90){
  print("優秀")
}else if(score>=60){
  print("及格")
}else{
  print("不及格")
}
```

`if-else if-else`敘述是有順序的，若在`if`敘述判斷為真，就算後方`else if`判斷也為真，也只會執行`if`區段的程式碼，如上述範例，95分大於等於90分(if邏輯)，也大於等於60分(else if邏輯)，但最後只印出**優秀**字樣。

###巢狀if
巢狀if是指在`if`區段程式碼內包含其他`if-else`判斷，舉例來說，若國文分數與英文分數皆大於等於60分，印出**全部及格**，國文分數大於等於60分，英文小於60分，則印**國文及格，英文再加油**，以此類推，程式範例如下:

```{r}
CHscore<-95 ##國文成績
ENscore<-55 ##英文成績
if(CHscore>=60){
  if(ENscore>=60){
    print("全部及格")
  }else{
    print("國文及格，英文再加油")
  }
}else{
  if(ENscore>=60){
    print("英文及格，國文再加油")
  }else{
    print("全部不及格")
  }
}
```

###ifelse() 
`ifelse()`函數可用最短的方式取代`if-else`敘述，使用方法為`ifelse(邏輯判斷,判斷為真要執行的程式碼,判斷為偽要執行的程式碼)`，依上述範例，重寫程式碼如下:

```{r}
score<-80
ifelse(score>=60,"及格","不及格")
```

值得注意的是，`ifelse()`可判斷向量，也就是可一次**判斷多個元素**
```{r}
scoreVector<-c(30,90,50,60,80)
ifelse(scoreVector>=60,"及格", "不及格")
```
##迴圈

###for
R語言的`for`迴圈寫法和其他語言不同，首先必須建立需要逐一執行的參數向量或序列，再使用`for`迴圈逐一執行，程式寫法為`for (單一變數 in 參數向量){ 程式碼 }`，範例如下:
```{r}
for (n in 1:10){ #n為單一變數，1:10為需要逐一執行的參數向量
  print(n)
}
```
`for`迴圈也可和`if-else`函數合併使用，如:
```{r}
for (n in 1:10){
  if(n%%2==0){ #偶數直接輸出數字
    print(n)
  }else{
    print("奇數") #奇數則輸出"奇數"
  }
}
```
###while
`while`函數則是在每次執行迴圈時檢查while邏輯判斷是否為真，若邏輯判斷為真，就會執行區段程式碼，若邏輯判斷為偽，則會結束迴圈執行。
```{r}
x<-0
while(x<=5){
  print(x)
  x<-x+1
}
```
###break
若遇特殊情形想**結束**迴圈執行，可使用`break`指令
```{r}
for(n in 1:10){
  if(n==5){
    break ##一執行到5，跳出迴圈，不再執行之後的迴圈
  }
  print(n)
}
```
###next
若遇特殊情形想**跳過**迴圈執行，可使用`next`指令
```{r}
for(n in 1:10){
  if(n==5){
    next ##跳過5，直接執行下一個迴圈
  }
  print(n)
}
```

##purrr
better than sapply() and lapply()

